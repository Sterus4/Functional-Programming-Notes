# Functional-Programming-Notes

Нигаматуллин Степан, Марк Ефремов P3334. 

Конспект лекции по функциональному программированию - Динамическая верификация

## Валидация. Верификация - основные понятия

Валидация и верификация - базовые понятия для компьютерных систем.

**Валидация** - проверка системы на соответствие неформализованному запросу стейкхолдеров
Отвечает на вопрос "Have we done the **right thing**?"

**Верификация** - проверка на соответствие спецификации
Отвечает на вопрос: "Have we **done** the thing **right**?"

Таким образом, верификация требует наличия документа с формализованными требованиями, на основе которого будут проводиться проверки.

В лекции приводится пример Большой Берты - орудия времён Первой мировой войны. Эта пушка соответствовала функциональным требованиям: стреляла с огромной разрушительной силой на большие расстояния, однако использовать её было нецелесообразно. Ввиду веса в 41 тонну, она могла перемещаться только по железной дороге, что делало её использование на линии фронта затруднительным. То есть, она успешно проходила верификационные испытания, но не валидационные.

https://se.ifmo.ru/documents/10180/671657/%D0%9B%D0%B5%D0%BA%D1%86%D0%B8%D0%B8+%D0%BF%D0%BE+%D0%9E%D0%9F%D0%98+v1.3.3.pdf/50ce1e06-00d9-4900-be9c-a3316a746d6d

## Подходы к верификации - основные понятия
Верификация делится на два класса:
- **Динамическая** - осуществляется через эксперимент. Тестирование в привычном понимании этого слова.
- **Статическая** - проверки применяются к артефактам программной системы: код как текст, документация, модели. Запуск программы, и даже само существование готовой системы не требуется.

Эксперимент затрагивает набор конкретных тестовых случаев.
Поэтому он не способен продемонстрировать отсутствие ошибок, лишь выявить их с некоторой вероятностью. 


В то же самое время, статическая верификация позволяет рассуждать о целых категориях вопросов, касательно поведения системы. Проще говоря, проверяет её свойства.
[Стоит ли здесь сказать, что это даёт больше гарантий корректности ценой трудоёмкости, или это и так очевидно?]
Подобная работа с общим случаем крайне затруднительна и требует различных ухищрений. 
[Дополнение: Например, при проверке всех ветвей исполнения программы, возникает path explosion, с которым необходимо бороться, склеивая ветви и разворачивая циклы.]

## Динамическая верификация - виды (основные понятия)
Марк

## REPL - READ EVAL PRINT LOOP
Степан

## Автоматические тесты - виды
Марк

## Unit-tests vs. Integration Tests 
Марк

## Test coverage
Метрикой качества динамической верификации служит тестовое покрытие. 
Чаще всего, под этим понятием подразумевают процентное соотношение строк кода, которые выполняются во время тестов, к общему объёму.

Однако при подобном способе оценки даже 100% покрытие не гарантирует качественного тестирования.

В приведённом ниже примере, абсолютно все строки функции будут хотя бы единожды выполнены в тестах благодаря первым трём `assert`. Тем не менее, оставшаяся комбинация входных аргументов, `True, True`, приводит к возникновению ошибки.

```python
def f(a: bool, b: bool):
    lst = [1, 2]
    i = 0
    if a: i+=1
    if b: i+=1
    return lst[i]

assert f(False, False)
assert f(False, True)
assert f(True, False)
# here we have full test coverage for fucntion f
# but:
assert f(True, True)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 6, in f
IndexError: list index out of range
```

Выходом из подобной ситуации служит использование другой метрики - покрытие путей исполнения (path coverage).
В этом случае, в тестах требуется пройти все возможные пути исполнения программы, которые возникают при ветвлении.

Благодаря продвинутым техникам программного анализа, вроде символьного исполнения, возможно автоматически найти небольшой набор комбинаций входых аргументов, проверка которого обеспечит 100% path coverage.

Но когда дело касается нетривиальных программ, содержащих вложенные циклы, или циклы, число итераций которых зависит от переменных, проверка всех путей не представляется возможной.

Таким образом, ориентироваться исключительно на подобные метрики не стоит. Вместо этого, следует отдать предпочтение вдумчивому написанию тестов,  с опорой на структуру исходного кода и анализ предметной области.

https://www.researchgate.net/publication/276198111_Black_Box_and_White_Box_Testing_Techniques_-_A_Literature_Review

## doctest ? 
Степан

## Golden Master Testing
Степан

## Fuzzy and Monkey Testing
Марк

## Race Condition Detection
Степан
## Property-Based Testing
Степан
