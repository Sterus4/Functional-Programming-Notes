# Functional-Programming-Notes

Нигаматуллин Степан, Марк Ефремов P3334. 

Конспект лекции по функциональному программированию - Динамическая верификация

## Валидация. Верификация - основные понятия

Валидация и верификация - базовые понятия для компьютерных систем.

**Валидация** - проверка системы на соответствие неформализованному запросу стейкхолдеров
Отвечает на вопрос "Have we done the **right thing**?"

**Верификация** - проверка на соответствие спецификации
Отвечает на вопрос: "Have we **done** the thing **right**?"

Таким образом, верификация требует наличия документа с формализованными требованиями, на основе которого будут проводиться проверки.

В лекции приводится пример Большой Берты - орудия времён Первой мировой войны. Эта пушка соответствовала функциональным требованиям: стреляла с огромной разрушительной силой на большие расстояния, однако использовать её было нецелесообразно. Ввиду веса в 41 тонну, она могла перемещаться только по железной дороге, что делало её использование на линии фронта затруднительным. То есть, она успешно проходила верификационные испытания, но не валидационные.

Подробнее:<br>
https://se.ifmo.ru/documents/10180/671657/Лекции+по+ОПИ+v1.3.3.pdf/50ce1e06-00d9-4900-be9c-a3316a746d6d

## Подходы к верификации - основные понятия
Верификация делится на два класса:
- **Динамическая** - осуществляется через эксперимент. Тестирование в привычном понимании этого слова.
- **Статическая** - проверки применяются к артефактам программной системы: код как текст, документация, модели. Запуск программы, и даже само существование готовой системы не требуется.

Эксперимент затрагивает набор конкретных тестовых случаев.
Поэтому он не способен продемонстрировать отсутствие ошибок, лишь выявить их с некоторой вероятностью. 


В то же самое время, статическая верификация позволяет рассуждать о целых категориях вопросов, касательно поведения системы. Проще говоря, проверяет её свойства.

Это даёт больше гарантий корректности, но подобная работа с общим случаем крайне затруднительна и требует ухищрений. 
Например, при проверке всех ветвей исполнения программы, возникает [path explosion](https://en.wikipedia.org/wiki/Path_explosion), с которым необходимо бороться, склеивая ветви и разворачивая циклы.

## Динамическая верификация - виды (основные понятия)
Марк

## REPL - READ EVAL PRINT LOOP
Степан

## Автоматические тесты - виды
Марк

## Unit-tests vs. Integration Tests 
Марк

## Test coverage
Метрикой качества динамической верификации служит тестовое покрытие. 
Чаще всего, под этим понятием подразумевают процентное соотношение строк кода, которые выполняются во время тестов, к общему объёму.

Однако при подобном способе оценки даже 100% покрытие не гарантирует качественного тестирования.

В приведённом ниже примере, абсолютно все строки функции будут хотя бы единожды выполнены в тестах благодаря первым трём `assert`. Тем не менее, оставшаяся комбинация входных аргументов, `True, True`, приводит к возникновению ошибки.

```python
def f(a: bool, b: bool):
    lst = [1, 2]
    i = 0
    if a: i+=1
    if b: i+=1
    return lst[i]

assert f(False, False)
assert f(False, True)
assert f(True, False)
# here we have full test coverage for fucntion f
# but:
assert f(True, True)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 6, in f
IndexError: list index out of range
```

Выходом из подобной ситуации служит использование другой метрики - покрытие путей исполнения (path coverage).
В этом случае, в тестах требуется пройти все возможные пути исполнения программы, которые возникают при ветвлении.

Благодаря продвинутым техникам программного анализа, вроде [символьного исполнения](https://en.wikipedia.org/wiki/Symbolic_execution), возможно автоматически найти небольшой набор комбинаций входых аргументов, проверка которого обеспечит 100% path coverage.

Но когда дело касается нетривиальных программ, содержащих вложенные циклы, или циклы, число итераций которых зависит от переменных, проверка всех путей не представляется возможной.

Таким образом, ориентироваться исключительно на подобные метрики не стоит. Вместо этого, следует отдать предпочтение вдумчивому написанию тестов, с опорой на структуру исходного кода и анализ предметной области.

Подробнее:<br>
https://www.researchgate.net/publication/276198111_Black_Box_and_White_Box_Testing_Techniques_-_A_Literature_Review

## doctest ? 
Степан

## Golden Master Testing
Степан

## Fuzzy and Monkey Testing
Входные данные некоторых систем могут быть крайне вариативны, что вызывает трудности при тестировании.

Взять, например, компилятор. Множество исходных программ, которые он должен обрабатывать, безгранично. Как убедиться в том, что он работает корректно? Какие тестовые случаи рассматривать?

В подобных ситуациях, когда необходимо протестировать большое количество комбинаций чего-либо, применяется **фаззинг**. 

> The term “fuzz” was originally coined by Miller et al. in 1990 to refer to a program that “generates a stream of random characters to be consumed by a target program

В общем смысле этого слова, фаззинг описывает процесс автоматического тестирования программы «мусорными данными». То есть, приоритет отдаётся объёму и разнообразию тестов, а не их точности.

Легче всего использовать фаззинг для penetration testing. В этом случае, в процессе фаззинга входные данные намеренно искажаются. Они слегка «выходят за рамки» значений, ожидаемых программой. При запуске программы на этих искажённых, невалидных данных, проводится проверка, что они были успешно отвергнуты программой в результате внутренних проверок и обработки.

Однако можно тестировать и более сложные свойства. Для этого в фаззерах задают «оракул» - модуль, которые проверяет их соблюдение.

**Generation-based** (или model-based) **фаззеры** генерируют входные данные, основываясь на модели, которую им предоставили. Например, для компилятора generation-based фаззер будет генерировать программы, основываясь на грамматике языка, заданной в форме EBNF (grammar-based input generation). Зачастую фаззеры предоставляют API, благодаря которому тестировщик может задать требуемую модель.


**Mutation-based фаззеры**, не требуют модели входных данных. Вместо этого, они меняют уже готовый набор входных данных. 

Ограничением random testing является то, что сгенерированные данные лишь с небольшим шансом затронут интересующие нас области программы, поскольку они могут 
быть отвергнуты в результате внутренних проверок. 

Без дополнительного анализа, сложно определить требуемую структуру входных данных. Например, как сгенерировать с нуля валидный mp3-файл? Здесь можно обратиться к принципу локальности – если входные данные валидные, то, изменив их небольшую часть, мы всё равно с большой вероятностью получим валидные данные.
Таким образом, специфика mutation-based фаззеров заключается в том, что предоставленные примеры входных данных меняются лишь слегка. Например, инвертируются несколько бит. 

Источники:<br>
[The Art, Science, and Engineering of Fuzzing:
A Survey](https://arxiv.org/pdf/1812.00140)<br>
[A Survey of Modern Compiler Fuzzing](https://arxiv.org/pdf/2306.06884)


**Monkey Testing** – разновидность random testing, которая сильно напоминает фаззинг. Суть заключается в том, что к тестируемой программе применяется последовательность случайных действий, с намерением её сломать.

Проводится аналогия с обезъяной, которая лазает по тестрируемой системе и беспорядочно жмёт на все кнопки.

Эта техника подходит для распределённых систем. В таком случае, отключаются произвольные куски системы, микросервисы, а затем проверяется её работоспособность.

## Race Condition Detection
Степан
## Property-Based Testing
Степан
